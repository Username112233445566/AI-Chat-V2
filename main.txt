‚îú‚îÄ‚îÄ apps
‚îÇ   ‚îú‚îÄ‚îÄ assistant
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ apps.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bot
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bot.py
from aiogram import Bot
from aiogram.enums import ParseMode
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from apps.service.settings_service import get_bot_token
from asgiref.sync import sync_to_async
from apps.assistant.models import AssistantUser

BOT_TOKEN = get_bot_token()

bot = Bot(
    token=BOT_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)

dp = Dispatcher()

@sync_to_async
def get_or_create_user(tg_id: int, full_name: str) -> AssistantUser:
    """
    –°–æ–∑–¥–∞—ë—Ç –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –æ–±–Ω–æ–≤–ª—è—è –µ–≥–æ –∏–º—è –∏ –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.
    """
    user, created = AssistantUser.objects.get_or_create(
        tg_id=tg_id,
        defaults={"full_name": full_name}
    )
    user.full_name = full_name
    user.save(update_fields=["full_name", "last_message_at"])
    return user
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ChatAction

import os
import tempfile
import re
import time

from apps.assistant.bot.bot import bot, get_or_create_user
from apps.service.ai_service import process_ai_request
from apps.service.whisper_service import transcribe_voice
from apps.service.yougile_service import create_task, get_tasks, delete_task

router = Router()
pending_tasks = {}
task_lookup_by_user = {}

def confirm_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É", callback_data="confirm_create")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
    ])

def delete_keyboard(user_id: int):
    tasks = task_lookup_by_user.get(user_id, [])
    buttons = [
        [InlineKeyboardButton(text=t["title"], callback_data=f"delete:{t['id']}")]
        for t in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None

def parse_task_block(text: str) -> dict:
    title = text.split("\n")[0].strip()
    description = "\n".join(text.split("\n")[1:]).strip()

    deadline_ts = None
    priority = "task-green"

    if "–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –≤—ã—Å–æ–∫–∏–π" in text.lower():
        priority = "task-red"
    elif "–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å—Ä–µ–¥–Ω–∏–π" in text.lower():
        priority = "task-yellow"

    match = re.search(r"(\d{4}-\d{2}-\d{2})", text)
    if match:
        try:
            struct_time = time.strptime(match.group(1), "%Y-%m-%d")
            deadline_ts = int(time.mktime(struct_time) * 1000)
        except:
            pass

    return {
        "title": title,
        "description": description,
        "priority": priority,
        "deadline_ts": deadline_ts
    }

@router.message(F.text)
async def handle_text(message: Message):
    user = await get_or_create_user(
        tg_id=message.from_user.id,
        full_name=message.from_user.full_name or message.from_user.username or "Unknown"
    )

    if not user.can_submit_tasks:
        await message.answer("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞.")
        return

    await bot.send_chat_action(chat_id=message.chat.id, action=ChatAction.TYPING)
    response_text, action = await process_ai_request(user, message.text)

    if action == "[CREATE_TASK]":
        pending_tasks[user.tg_id] = response_text
        await message.answer(response_text, reply_markup=confirm_keyboard())

    elif action == "[SHOW_TASKS]":
        tasks = await get_tasks()
        if tasks:
            formatted = "\n\n".join([f"üìå <b>{t['title']}</b>\n{t.get('description', '')}" for t in tasks])
            await message.answer(f"–í–æ—Ç –≤–∞—à–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏:\n\n{formatted}", parse_mode="HTML")
        else:
            await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á.")
        return

    elif action == "[DELETE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("üì≠ –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=delete_keyboard(user.tg_id))

    else:
        await message.answer(response_text)

@router.message(F.voice)
async def handle_voice(message: Message):
    user = await get_or_create_user(
        tg_id=message.from_user.id,
        full_name=message.from_user.full_name or message.from_user.username or "Unknown"
    )

    if not user.can_submit_tasks:
        await message.answer("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞.")
        return

    voice = message.voice
    file = await bot.download(voice.file_id)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".ogg") as temp_audio:
        temp_audio.write(file.getvalue())
        temp_audio_path = temp_audio.name

    await bot.send_chat_action(chat_id=message.chat.id, action=ChatAction.TYPING)
    transcribed_text = await transcribe_voice(temp_audio_path)

    os.remove(temp_audio_path)

    if not transcribed_text.strip():
        await message.answer("üõë –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        return

    response_text, action = await process_ai_request(user, transcribed_text)

    if action == "[CREATE_TASK]":
        pending_tasks[user.tg_id] = response_text
        await message.answer(response_text, reply_markup=confirm_keyboard())

    elif action == "[SHOW_TASKS]":
        tasks = await get_tasks()
        if tasks:
            formatted = "\n\n".join([f"üìå <b>{t['title']}</b>\n{t.get('description', '')}" for t in tasks])
            await message.answer(f"–í–æ—Ç –≤–∞—à–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏:\n\n{formatted}", parse_mode="HTML")
        else:
            await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á.")
        return

    elif action == "[DELETE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("üì≠ –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=delete_keyboard(user.tg_id))

    else:
        await message.answer(response_text)

@router.callback_query(F.data == "confirm_create")
async def handle_confirm_create(callback: CallbackQuery):
    user_id = callback.from_user.id
    if user_id not in pending_tasks:
        await callback.message.answer("‚ö†Ô∏è –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–¥–∞—á–∏.")
        await callback.answer()
        return

    task_text = pending_tasks.pop(user_id)
    parsed = parse_task_block(task_text)

    success = await create_task(
        title=parsed["title"],
        description=parsed["description"],
        priority=parsed["priority"],
        deadline_ts=parsed["deadline_ts"]
    )

    if success:
        await callback.message.edit_text(f"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ –≤ YouGile:\n\n{parsed['title']}")
    else:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É –≤ YouGile.")

    await callback.answer("–ì–æ—Ç–æ–≤–æ.")

@router.callback_query(F.data.startswith("delete:"))
async def confirm_delete(callback: CallbackQuery):
    task_id = callback.data.split(":", 1)[1]
    success = await delete_task(task_id)
    if success:
        await callback.message.edit_text("üóë –ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞.")
    else:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É.")
    await callback.answer()
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ start_bot.py
import asyncio
from apps.assistant.bot.bot import bot, dp
from apps.assistant.bot.handlers import router

async def start_bot():
    dp.include_router(router)
    await dp.start_polling(bot)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ management
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commands
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ runbot.py
from django.core.management.base import BaseCommand
import asyncio
from apps.assistant.bot.start_bot import start_bot

class Command(BaseCommand):
    help = '–ó–∞–ø—É—Å–∫ Telegram-–±–æ—Ç–∞'

    def handle(self, *args, **options):
        asyncio.run(start_bot())
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py
from django.db import models


class BaseModel(models.Model):
    is_active = models.BooleanField(default=True, verbose_name='–ê–∫—Ç–∏–≤–µ–Ω')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='–î–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è')

    class Meta:
        abstract = True


class TelegramGroup(BaseModel):
    name = models.CharField(max_length=255, verbose_name='–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã')
    chat_id = models.BigIntegerField(unique=True, verbose_name='Chat ID')

    def str(self):
        return self.name

    class Meta:
        verbose_name = 'Telegram-–≥—Ä—É–ø–ø–∞'
        verbose_name_plural = 'Telegram-–≥—Ä—É–ø–ø—ã'


class YouGileBoard(BaseModel):
    name = models.CharField(max_length=255, verbose_name='–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ—Å–∫–∏')
    api_key = models.TextField(verbose_name='API Key')
    board_id = models.CharField(max_length=255, verbose_name='Board ID')
    column_id = models.CharField(max_length=255, verbose_name='Column ID')

    def str(self):
        return self.name

    class Meta:
        verbose_name = 'YouGile-–¥–æ—Å–∫–∞'
        verbose_name_plural = 'YouGile-–¥–æ—Å–∫–∏'


class AssistantKeywords(BaseModel):
    keywords = models.CharField(max_length=255, verbose_name='–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞')
    description = models.TextField(verbose_name='–û–ø–∏—Å–∞–Ω–∏–µ')

    def str(self):
        return self.keywords

    class Meta:
        verbose_name = '–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞'
        verbose_name_plural = '–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞'


class AssistantPromt(BaseModel):
    prompt = models.TextField(verbose_name='–ü—Ä–æ–º—Ç')

    def str(self):
        return self.prompt[:50] + "..." if len(self.prompt) > 50 else self.prompt

    class Meta:
        verbose_name = '–ü—Ä–æ–º—Ç'
        verbose_name_plural = '–ü—Ä–æ–º—Ç—ã'


class Secret(BaseModel):
    value_bot = models.TextField(verbose_name='Telegram bot')
    value_ai = models.TextField(verbose_name='AI key')
    value_group = models.TextField(verbose_name='Group')

    yougile_api_key = models.TextField(verbose_name='YouGile API Key')
    yougile_board_id = models.TextField(verbose_name='YouGile Board ID')
    yougile_column_id = models.TextField(verbose_name='YouGile Column ID')

    def str(self):
        return self.value_bot[:12] + "..."

    class Meta:
        verbose_name = '–°–µ–∫—Ä–µ—Ç'
        verbose_name_plural = '–°–µ–∫—Ä–µ—Ç—ã'


class AssistantUser(BaseModel):
    tg_id = models.BigIntegerField(unique=True, verbose_name='Telegram ID')
    full_name = models.CharField(max_length=255, verbose_name='–ò–º—è')

    first_seen_at = models.DateTimeField(auto_now_add=True, verbose_name='–ü–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ')
    last_message_at = models.DateTimeField(auto_now=True, verbose_name='–ü–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ')

    can_submit_tasks = models.BooleanField(default=False, verbose_name='–†–∞–∑—Ä–µ—à–µ–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∑–∞–¥–∞—á–∏')

    telegram_groups = models.ManyToManyField(TelegramGroup, blank=True, verbose_name='Telegram-–≥—Ä—É–ø–ø—ã')
    yougile_boards = models.ManyToManyField(YouGileBoard, blank=True, verbose_name='YouGile-–¥–æ—Å–∫–∏')

    def str(self):
        return f"{self.full_name} ({self.tg_id})"

    class Meta:
        verbose_name = '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'
        verbose_name_plural = '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏'
‚îÇ   ‚îî‚îÄ‚îÄ service
‚îÇ       ‚îú‚îÄ‚îÄ ai_service.py
import asyncio
import logging
import google.generativeai as genai
from apps.service.settings_service import get_ai_key

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

GOOGLE_API_KEY = get_ai_key()
genai.configure(api_key=GOOGLE_API_KEY)
genai_model = genai.GenerativeModel("gemini-2.0-flash")

UNIFIED_ASSISTANT_PROMPT = """
–¢—ã ‚Äî —É–º–Ω—ã–π AI-–ø–æ–º–æ—â–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –≤–µ–¥—ë—Ç –¥–∏–∞–ª–æ–≥ –∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞—á–∞–º–∏ –æ—Ç –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.

–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:
1. –û–±—â–∞–π—Å—è, –∫–∞–∫ –æ–±—ã—á–Ω—ã–π —á–∞—Ç-–±–æ—Ç.
2. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–Ω–æ –¥–∞—ë—Ç –∫–æ–º–∞–Ω–¥—É, —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–π –Ω–∞–º–µ—Ä–µ–Ω–∏–µ –∏ –¥–æ–±–∞–≤–ª—è–π –º–∞—Ä–∫–µ—Ä –≤ –æ—Ç–≤–µ—Ç.

‚ö†Ô∏è –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–π –º–∞—Ä–∫–µ—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é. –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–π –∏—Ö –≤ —Å–∞–º—ã–π –∫–æ–Ω–µ—Ü –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ.

–ö–æ–º–∞–Ω–¥–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã:
- –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–Ω–æ –ø—Ä–æ—Å–∏—Ç —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É (—Å–æ–∑–¥–∞–π, –∑–∞–ø–∏—à–∏, –¥–æ–±–∞–≤—å) ‚Üí –¥–æ–±–∞–≤—å [CREATE_TASK]
- –ï—Å–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞—á—É ‚Üí [UPDATE_TASK]
- –ï—Å–ª–∏ —É–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É ‚Üí [DELETE_TASK]
- –ï—Å–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –∑–∞–¥–∞—á–∏ (–ø–æ–∫–∞–∂–∏ –∑–∞–¥–∞—á–∏, –æ—Ç–æ–±—Ä–∞–∑–∏ —Å–ø–∏—Å–æ–∫, —á—Ç–æ —É –º–µ–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ, –≤—ã–≤–µ–¥–∏ –∑–∞–¥–∞—á–∏, –≤—Å–µ –∑–∞–¥–∞—á–∏ –∏ —Ç.–¥.) ‚Üí [SHOW_TASKS]
- –ò–Ω–∞—á–µ ‚Äî –Ω–µ –¥–æ–±–∞–≤–ª—è–π –Ω–∏–∫–∞–∫–∏—Ö –º–∞—Ä–∫–µ—Ä–æ–≤.

–ü—Ä–∏–º–µ—Ä—ã:
- "–°–æ–∑–¥–∞–π –∑–∞–¥–∞—á—É: –ø–æ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É" ‚Üí –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç + [CREATE_TASK]
- "–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –•" ‚Üí –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç + [DELETE_TASK]
- "–ü–æ–∫–∞–∂–∏ –º–Ω–µ –º–æ–∏ –∑–∞–¥–∞—á–∏" ‚Üí –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç + [SHOW_TASKS]
- "–ß—Ç–æ —É –º–µ–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ?" ‚Üí –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç + [SHOW_TASKS]
- "–ö–∞–∫ –¥–µ–ª–∞?" ‚Üí –æ–±—ã—á–Ω—ã–π –æ—Ç–≤–µ—Ç –±–µ–∑ –º–∞—Ä–∫–µ—Ä–∞
"""

async def process_ai_request(user, text: str) -> tuple[str, str]:
    text_lower = text.lower().strip()

    quick_phrases = ["–≤—Å–µ –∑–∞–¥–∞—á–∏", "–ø–æ–∫–∞–∂–∏ –∑–∞–¥–∞—á–∏", "–æ—Ç–æ–±—Ä–∞–∑–∏ –∑–∞–¥–∞—á–∏", "–≤—ã–≤–µ–¥–∏ –∑–∞–¥–∞—á–∏", "—á—Ç–æ —É –º–µ–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ", "—Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á"]
    if any(phrase in text_lower for phrase in quick_phrases):
        logger.info(f"‚ö° –ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã SHOW_TASKS –¥–ª—è: {text_lower}")
        return "üìã –í–æ—Ç –≤–∞—à–∏ –∑–∞–¥–∞—á–∏:", "[SHOW_TASKS]"

    prompt = UNIFIED_ASSISTANT_PROMPT + f"\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {text}\n–û—Ç–≤–µ—Ç:"
    try:
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(None, lambda: genai_model.generate_content(prompt))
        full_text = result.text.strip()

        action = None
        for marker in ["[CREATE_TASK]", "[UPDATE_TASK]", "[DELETE_TASK]", "[SHOW_TASKS]"]:
            if marker in full_text:
                action = marker
                full_text = full_text.replace(marker, "").strip()
                break

        logger.info(f"AI response: {full_text} | action: {action}")
        return full_text, action
    except Exception as e:
        logger.error(f"AI error for user {user.tg_id}: {e}", exc_info=True)
        return "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI.", None
‚îÇ       ‚îú‚îÄ‚îÄ settings_service.py
from apps.assistant.models import Secret
from django.core.exceptions import ObjectDoesNotExist
from asgiref.sync import sync_to_async

def get_secret():
    try:
        return Secret.objects.filter(is_active=True).latest("updated_at")
    except ObjectDoesNotExist:
        raise Exception("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∑–∞–ø–∏—Å–∏ –≤ Secret. –ó–∞–¥–∞–π –µ—ë —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω–∫—É.")

def get_bot_token():
    return get_secret().value_bot.strip()

def get_ai_key():
    return get_secret().value_ai.strip()

def get_default_group_id():
    return get_secret().value_group.strip()

@sync_to_async
def get_default_yougile_data():
    secret = get_secret()
    return {
        "api_key": secret.yougile_api_key.strip(),
        "board_id": secret.yougile_board_id.strip(),
        "column_id": secret.yougile_column_id.strip(),
    }
‚îÇ       ‚îú‚îÄ‚îÄ telegram_service.py
‚îÇ       ‚îú‚îÄ‚îÄ whisper_service.py
from pathlib import Path
import whisper
import torch
import asyncio
import logging

logger = logging.getLogger(__name__)

try:
    if torch.cuda.is_available():
        device = "cuda"
    elif torch.backends.mps.is_available():
        device = "mps"
    else:
        device = "cpu"
    logger.info(f"Whisper –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device}")
    model = whisper.load_model("base", device=device)
except Exception as e:
    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Whisper: {e}", exc_info=True)
    model = whisper.load_model("base", device="cpu")

async def transcribe_voice(file_path: str, language: str = None) -> str:
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ Whisper (—á–µ—Ä–µ–∑ executor).
    """
    loop = asyncio.get_running_loop()

    try:
        result = await loop.run_in_executor(
            None,
            lambda: model.transcribe(file_path, language=language)
        )
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞ {file_path}: {e}", exc_info=True)
        return ""
‚îÇ       ‚îî‚îÄ‚îÄ yougile_service.py
import aiohttp
import logging
from apps.service.settings_service import get_default_yougile_data

logger = logging.getLogger(__name__)


async def create_task(title: str, description: str = "", priority: str = "task-green", deadline_ts: int = None) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]
    column_id = data["column_id"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    payload = {
        "title": title[:100],
        "description": description,
        "columnId": column_id,
        "archived": False,
        "completed": False,
        "color": priority
    }

    if deadline_ts:
        payload["deadline"] = {
            "deadline": deadline_ts,
            "startDate": deadline_ts,
            "withTime": False,
            "history": [],
            "blockedPoints": [],
            "links": []
        }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post("https://api.yougile.com/api-v2/tasks", json=payload, headers=headers) as response:
                response_json = await response.json()
                if response.status in (200, 201) and "id" in response_json:
                    logger.info(f"‚úÖ –ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ YouGile: {response_json['id']}")
                    return True
                else:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {response.status} {response_json}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}", exc_info=True)
        return False


async def get_tasks(limit: int = 10, offset: int = 0) -> list[dict]:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/task-list?limit={limit}&offset={offset}"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                response_json = await response.json()
                if response.status == 200 and isinstance(response_json, dict):
                    return response_json.get("content", [])
                else:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–¥–∞—á: {response.status} ‚Äî {response_json}")
                    return []
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–¥–∞—á: {e}", exc_info=True)
        return []


async def delete_task(task_id: str) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/tasks/{task_id}"
    payload = {
        "deleted": True
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers, json=payload) as response:
                if response.status in (200, 204):
                    logger.info(f"üóë –ó–∞–¥–∞—á–∞ {task_id} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞.")
                    return True
                else:
                    text = await response.text()
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ {task_id}: {response.status} ‚Äî {text}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ {task_id}: {e}", exc_info=True)
        return False
‚îú‚îÄ‚îÄ core
‚îÇ   ‚îú‚îÄ‚îÄ asgi.py
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ urls.py
‚îÇ   ‚îî‚îÄ‚îÄ wsgi.py
‚îú‚îÄ‚îÄ db.sqlite3
‚îú‚îÄ‚îÄ manage.py