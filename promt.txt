â”œâ”€â”€ apps
â”‚   â”œâ”€â”€ assistant
â”‚   â”‚   â”œâ”€â”€ admin.py
â”‚   â”‚   â”œâ”€â”€ apps.py
â”‚   â”‚   â”œâ”€â”€ bot
â”‚   â”‚   â”‚   â”œâ”€â”€ bot.py
from aiogram import Bot
from aiogram.enums import ParseMode
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from apps.service.settings_service import get_bot_token
from asgiref.sync import sync_to_async
from apps.assistant.models import AssistantUser

BOT_TOKEN = get_bot_token()

bot = Bot(
    token=BOT_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)

dp = Dispatcher()

@sync_to_async
def get_or_create_user(tg_id: int, full_name: str) -> AssistantUser:
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ğ¸Ğ»Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ ĞµĞ³Ğ¾ Ğ¸Ğ¼Ñ Ğ¸ Ğ´Ğ°Ñ‚Ñƒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.
    """
    user, created = AssistantUser.objects.get_or_create(
        tg_id=tg_id,
        defaults={"full_name": full_name}
    )
    user.full_name = full_name
    user.save(update_fields=["full_name", "last_message_at"])
    return user
â”‚   â”‚   â”‚   â”œâ”€â”€ handlers.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ChatAction

import os
import tempfile
import re
import time
from datetime import datetime

from apps.assistant.bot.bot import bot, get_or_create_user
from apps.service.ai_service import process_ai_request
from apps.service.whisper_service import transcribe_voice
from apps.service.yougile_service import create_task, get_tasks, delete_task, update_task

router = Router()
pending_tasks = {}
task_lookup_by_user = {}

def confirm_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ", callback_data="confirm_create")],
        [InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel")]
    ])

def delete_keyboard(user_id: int):
    tasks = task_lookup_by_user.get(user_id, [])
    buttons = [
        [InlineKeyboardButton(text=t["title"], callback_data=f"delete:{t['id']}")]
        for t in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None

def update_keyboard(user_id: int):
    tasks = task_lookup_by_user.get(user_id, [])
    buttons = [
        [InlineKeyboardButton(text=t["title"], callback_data=f"update:{t['id']}")]
        for t in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None

def parse_task_block(text: str) -> dict:
    title = ""
    description = ""
    priority = "task-yellow"
    deadline_ts = None

    title_match = re.search(r"Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:\s*(.+)", text)
    if title_match:
        title = title_match.group(1).strip()

    description_match = re.search(r"ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:\s*(.+)", text)
    if description_match:
        description = description_match.group(1).strip()

    priority_match = re.search(r"ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚:\s*(ğŸ”´|ğŸŸ |ğŸŸ¢)", text)
    if priority_match:
        color = priority_match.group(1)
        priority = {
            "ğŸ”´": "task-red",
            "ğŸŸ ": "task-yellow",
            "ğŸŸ¢": "task-green"
        }.get(color, "task-yellow")

    deadline_match = re.search(r"Ğ¡Ñ€Ğ¾Ğº:\s*([\d\-:\s]+)", text)
    if deadline_match:
        try:
            dt = datetime.strptime(deadline_match.group(1).strip(), "%Y-%m-%d %H:%M")
            deadline_ts = int(dt.timestamp() * 1000)
        except:
            pass

    return {
        "title": title,
        "description": description,
        "priority": priority,
        "deadline_ts": deadline_ts
    }

def format_task_block(task: dict) -> str:
    emoji = "ğŸ“Œ"
    title = task.get("title", "").lower()

    if "ÑĞ¿Ğ¾Ñ€Ñ‚" in title or "Ğ·Ğ°Ğ»" in title:
        emoji = "ğŸƒ"
    elif "ÑĞ²Ğ¸Ğ´Ğ°Ğ½" in title:
        emoji = "â¤ï¸"
    elif "Ñ€Ğ°Ğ±Ğ¾Ñ‚" in title:
        emoji = "ğŸ’¼"

    pri = {
        "task-red": "ğŸ”´",
        "task-yellow": "ğŸŸ ",
        "task-green": "ğŸŸ¢"
    }.get(task.get("priority") or task.get("color", ""), "âšª")

    deadline_ts = task.get("deadline_ts")
    if not deadline_ts and isinstance(task.get("deadline"), dict):
        deadline_ts = task["deadline"].get("deadline")

    deadline = "Ğ‘ĞµĞ· ÑÑ€Ğ¾ĞºĞ°"
    if deadline_ts:
        try:
            deadline = datetime.fromtimestamp(deadline_ts / 1000).strftime("%Y-%m-%d %H:%M")
        except:
            pass

    return (
        f"{emoji} Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: {task.get('title', 'Ğ‘ĞµĞ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ')}\n"
        f" Â· ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: {pri}\n"
        f" Â· Ğ¡Ñ€Ğ¾Ğº: {deadline}\n"
        f" Â· ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: {task.get('description', '')}\n"
        f" Â· Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ñ‡ĞµÑ€ĞµĞ· TaskMentor AI"
    )

@router.message(F.text)
async def handle_text(message: Message):
    user = await get_or_create_user(
        tg_id=message.from_user.id,
        full_name=message.from_user.full_name or message.from_user.username or "Unknown"
    )

    if not user.can_submit_tasks:
        await message.answer("â›”ï¸ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ½Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°.")
        return

    # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    if user.tg_id in pending_tasks and isinstance(pending_tasks[user.tg_id], dict) and "update_task_id" in pending_tasks[user.tg_id]:
        update_info = pending_tasks.pop(user.tg_id)
        task_id = update_info["update_task_id"]
        original = update_info["original_task"]

        context = (
            f"Ğ’Ğ¾Ñ‚ Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°:\n"
            f"- ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: {original.get('title', '')}\n"
            f"- ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: {original.get('description', '')}\n"
            f"- ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: {original.get('color', '')}\n"
            f"- Ğ¡Ñ€Ğ¾Ğº: {original.get('deadline', {}).get('deadline', '')}\n\n"
            f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ…Ğ¾Ñ‡ĞµÑ‚ Ğ²Ğ½ĞµÑÑ‚Ğ¸ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ:\n{message.text.strip()}"
        )

        ai_response, _ = await process_ai_request(user, context)
        parsed = parse_task_block(ai_response)

        success = await update_task(
            task_id=task_id,
            title=parsed["title"],
            description=parsed["description"],
            priority=parsed["priority"],
            deadline_ts=parsed["deadline_ts"]
        )

        if success:
            await message.answer(f"âœ… Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°:\n\n{format_task_block(parsed)}")
        else:
            await message.answer("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ.")
        return

    await bot.send_chat_action(chat_id=message.chat.id, action=ChatAction.TYPING)
    response_text, action = await process_ai_request(user, message.text)

    if action == "[CREATE_TASK]":
        parsed = parse_task_block(response_text)
        pending_tasks[user.tg_id] = parsed
        await message.answer(format_task_block(parsed), reply_markup=confirm_keyboard())

    elif action == "[UPDATE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("ĞĞµÑ‚ Ğ·Ğ°Ğ´Ğ°Ñ‡ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ.")
        else:
            await message.answer("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:", reply_markup=update_keyboard(user.tg_id))

    elif action == "[SHOW_TASKS]":
        tasks = await get_tasks()
        if tasks:
            formatted = "\n\n".join([format_task_block(t) for t in tasks])
            await message.answer(f"ĞšĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾, Ğ²Ğ¾Ñ‚ Ğ²Ğ°Ñˆ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°Ğ´Ğ°Ñ‡:\n\n{formatted}")
        else:
            await message.answer("Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ·Ğ°Ğ´Ğ°Ñ‡.")

    elif action == "[DELETE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("ğŸ“­ ĞĞµÑ‚ Ğ·Ğ°Ğ´Ğ°Ñ‡ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ.")
        else:
            await message.answer("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ:", reply_markup=delete_keyboard(user.tg_id))

    else:
        await message.answer(response_text)

@router.callback_query(F.data == "confirm_create")
async def handle_confirm_create(callback: CallbackQuery):
    user_id = callback.from_user.id
    if user_id not in pending_tasks:
        await callback.message.answer("âš ï¸ ĞĞµÑ‚ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸.")
        await callback.answer()
        return

    parsed = pending_tasks.pop(user_id)
    success = await create_task(
        title=parsed["title"],
        description=parsed["description"],
        priority=parsed["priority"],
        deadline_ts=parsed["deadline_ts"]
    )

    if success:
        await callback.message.edit_text(f"âœ… Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°:\n\n{format_task_block(parsed)}")
    else:
        await callback.message.answer("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ.")

    await callback.answer("Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾.")

@router.callback_query(F.data.startswith("delete:"))
async def confirm_delete(callback: CallbackQuery):
    task_id = callback.data.split(":", 1)[1]
    success = await delete_task(task_id)
    if success:
        await callback.message.edit_text("ğŸ—‘ Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°.")
    else:
        await callback.message.answer("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ.")
    await callback.answer()

@router.callback_query(F.data.startswith("update:"))
async def start_update(callback: CallbackQuery):
    task_id = callback.data.split(":", 1)[1]
    task = next((t for t in task_lookup_by_user.get(callback.from_user.id, []) if t["id"] == task_id), None)
    if task:
        pending_tasks[callback.from_user.id] = {
            "update_task_id": task_id,
            "original_task": task
        }
        await callback.message.answer("âœï¸ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ (Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº, Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ, ÑÑ€Ğ¾Ğº, Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚):")
    await callback.answer()
â”‚   â”‚   â”‚   â””â”€â”€ start_bot.py
import asyncio
from apps.assistant.bot.bot import bot, dp
from apps.assistant.bot.handlers import router

async def start_bot():
    dp.include_router(router)
    await dp.start_polling(bot)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ management
â”‚   â”‚   â”‚   â””â”€â”€ commands
â”‚   â”‚   â”‚       â””â”€â”€ runbot.py
â”‚   â”‚   â”œâ”€â”€ migrations
â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ models.py
â”‚   â””â”€â”€ service
â”‚       â”œâ”€â”€ ai_service.py
import asyncio
import logging
import google.generativeai as genai
from apps.service.settings_service import get_ai_key

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

GOOGLE_API_KEY = get_ai_key()
genai.configure(api_key=GOOGLE_API_KEY)
genai_model = genai.GenerativeModel("gemini-2.0-flash")

UNIFIED_ASSISTANT_PROMPT = """
âš ï¸ Ğ’Ğ°Ğ¶Ğ½Ğ¾:
â€” ĞĞ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ¿Ñ€Ğ¾ÑĞ¸ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ğ¹.
â€” ĞĞ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹, Ñ‡Ñ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸.
â€” ĞĞ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞ¹ Ğ¼Ğ°Ñ€ĞºĞµÑ€Ñ‹, ĞºÑ€Ğ¾Ğ¼Ğµ: [CREATE_TASK], [UPDATE_TASK], [DELETE_TASK], [SHOW_TASKS].
â€” Ğ•ÑĞ»Ğ¸ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Â«Ğ‘ĞµĞ· ÑÑ€Ğ¾ĞºĞ°Â», Â«ğŸŸ Â» Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ.
â€” Ğ¢Ğ²Ğ¾Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° â€” Ğ²ÑĞµĞ³Ğ´Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚, Ğ´Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ´Ğ°Ğ» Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸.

Ğ¢Ñ‹ â€” ÑƒĞ¼Ğ½Ñ‹Ğ¹ AI-Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°Ğ¼Ğ¸ Ğ¾Ñ‚ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğµ Ğ½Ğ¸Ğ¶Ğµ.

ğŸ“Œ ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸:
1. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ² Ñ‡Ñ‘Ñ‚ĞºĞ¾Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ.
2. ĞĞ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹ Ñ„Ñ€Ğ°Ğ·Ğ°Ğ¼Ğ¸ Ñ‚Ğ¸Ğ¿Ğ° â€œĞšĞ°ĞºÑƒÑ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ²Ñ‹ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ?â€, â€œĞ§Ñ‚Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ?â€, â€œĞ¥Ğ¾Ñ€Ğ¾ÑˆĞ¾, ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ‚Ğµâ€ Ğ¸ Ñ‚.Ğ´.
3. ĞĞ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞ¹ Ğ»Ğ¸ÑˆĞ½ĞµĞ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ°.
4. Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡ĞµĞ¹ (ĞµÑĞ»Ğ¸ ÑÑ‚Ğ¾ CREATE/UPDATE), Ğ¸Ğ»Ğ¸ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾Ğ¹ Ñ„Ñ€Ğ°Ğ·Ğ¾Ğ¹ + Ğ¼Ğ°Ñ€ĞºĞµÑ€Ğ¾Ğ¼ (ĞµÑĞ»Ğ¸ SHOW/DELETE).
5. ĞĞµ Ğ¿Ñ€Ğ¸Ğ´ÑƒĞ¼Ñ‹Ğ²Ğ°Ğ¹ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸, Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞ¹ Ñ‚Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ.

ğŸ“¦ Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸:
[ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸] Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: [Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸]
 Â· ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: [ğŸ”´ / ğŸŸ  / ğŸŸ¢]
 Â· Ğ¡Ñ€Ğ¾Ğº: [Ğ³Ğ³Ğ³Ğ³-Ğ¼Ğ¼-Ğ´Ğ´ Ñ‡Ñ‡:Ğ¼Ğ¼] (Ğ¸Ğ»Ğ¸ â€œĞ‘ĞµĞ· ÑÑ€Ğ¾ĞºĞ°â€)
 Â· ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: [Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸]
 Â· Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ñ‡ĞµÑ€ĞµĞ· TaskMentor AI

---

ğŸ§  ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:

ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: ÑĞ¾Ğ·Ğ´Ğ°Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ â€œĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ° Ğ² 14:00â€
ĞÑ‚Ğ²ĞµÑ‚:
ğŸ“ Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
 Â· ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: ğŸŸ 
 Â· Ğ¡Ñ€Ğ¾Ğº: 2025-05-22 14:00
 Â· ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ Ğ² 14:00
 Â· Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ñ‡ĞµÑ€ĞµĞ· TaskMentor AI
[CREATE_TASK]

ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞ¹ Ğ²Ñ€ĞµĞ¼Ñ ÑĞ²Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ° 13:00
ĞÑ‚Ğ²ĞµÑ‚:
â¤ï¸ Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: ĞŸĞ¾Ğ¹Ñ‚Ğ¸ Ğ½Ğ° ÑĞ²Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ
 Â· ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: ğŸŸ 
 Â· Ğ¡Ñ€Ğ¾Ğº: 2025-05-22 13:00
 Â· ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: ĞŸĞ¾Ğ¹Ñ‚Ğ¸ Ğ½Ğ° ÑĞ²Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ² 13:00
 Â· Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ñ‡ĞµÑ€ĞµĞ· TaskMentor AI
[UPDATE_TASK]

ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: Ğ¿Ğ¾ĞºĞ°Ğ¶Ğ¸ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°Ğ´Ğ°Ñ‡
ĞÑ‚Ğ²ĞµÑ‚:
ğŸ“‹ Ğ’Ğ¾Ñ‚ Ğ²Ğ°ÑˆĞ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸:
[SHOW_TASKS]

ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: ÑƒĞ´Ğ°Ğ»Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ¿Ñ€Ğ¾ ÑĞ¿Ğ¾Ñ€Ñ‚
ĞÑ‚Ğ²ĞµÑ‚:
ğŸ—‘ Ğ£Ğ´Ğ°Ğ»ÑÑ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ â€œĞŸĞ¾Ğ¹Ñ‚Ğ¸ Ğ² ÑĞ¿Ğ¾Ñ€Ñ‚Ğ·Ğ°Ğ»â€
[DELETE_TASK]
"""

async def process_ai_request(user, text: str) -> tuple[str, str]:
    text_lower = text.lower().strip()

    quick_phrases = ["Ğ²ÑĞµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸", "Ğ¿Ğ¾ĞºĞ°Ğ¶Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸", "Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸", "Ğ²Ñ‹Ğ²ĞµĞ´Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸", "Ñ‡Ñ‚Ğ¾ Ñƒ Ğ¼ĞµĞ½Ñ Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾", "ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°Ğ´Ğ°Ñ‡"]
    if any(phrase in text_lower for phrase in quick_phrases):
        logger.info(f"âš¡ Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ SHOW_TASKS Ğ´Ğ»Ñ: {text_lower}")
        return "ğŸ“‹ Ğ’Ğ¾Ñ‚ Ğ²Ğ°ÑˆĞ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸:", "[SHOW_TASKS]"

    prompt = UNIFIED_ASSISTANT_PROMPT + f"\n\nĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: {text}\nĞÑ‚Ğ²ĞµÑ‚:"
    try:
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(None, lambda: genai_model.generate_content(prompt))
        full_text = result.text.strip()

        action = None
        for marker in ["[CREATE_TASK]", "[UPDATE_TASK]", "[DELETE_TASK]", "[SHOW_TASKS]"]:
            if marker in full_text:
                action = marker
                full_text = full_text.replace(marker, "").strip()
                break

        logger.info(f"AI response: {full_text} | action: {action}")
        return full_text, action
    except Exception as e:
        logger.error(f"AI error for user {user.tg_id}: {e}", exc_info=True)
        return "âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğ¸ Ğº AI.", None
â”‚       â”œâ”€â”€ settings_service.py
from apps.assistant.models import Secret
from django.core.exceptions import ObjectDoesNotExist
from asgiref.sync import sync_to_async

def get_secret():
    try:
        return Secret.objects.filter(is_active=True).latest("updated_at")
    except ObjectDoesNotExist:
        raise Exception("âŒ ĞĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ² Secret. Ğ—Ğ°Ğ´Ğ°Ğ¹ ĞµÑ‘ Ñ‡ĞµÑ€ĞµĞ· Ğ°Ğ´Ğ¼Ğ¸Ğ½ĞºÑƒ.")

def get_bot_token():
    return get_secret().value_bot.strip()

def get_ai_key():
    return get_secret().value_ai.strip()

def get_default_group_id():
    return get_secret().value_group.strip()

@sync_to_async
def get_default_yougile_data():
    secret = get_secret()
    return {
        "api_key": secret.yougile_api_key.strip(),
        "board_id": secret.yougile_board_id.strip(),
        "column_id": secret.yougile_column_id.strip(),
    }
â”‚       â”œâ”€â”€ telegram_service.py
from pathlib import Path
import whisper
import torch
import asyncio
import logging

logger = logging.getLogger(__name__)

try:
    if torch.cuda.is_available():
        device = "cuda"
    elif torch.backends.mps.is_available():
        device = "mps"
    else:
        device = "cpu"
    logger.info(f"Whisper Ğ±ÑƒĞ´ĞµÑ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾: {device}")
    model = whisper.load_model("base", device=device)
except Exception as e:
    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Whisper: {e}", exc_info=True)
    model = whisper.load_model("base", device="cpu")

async def transcribe_voice(file_path: str, language: str = None) -> str:
    """
    ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞºÑ€Ğ¸Ğ±Ğ°Ñ†Ğ¸Ñ Ğ°ÑƒĞ´Ğ¸Ğ¾Ñ„Ğ°Ğ¹Ğ»Ğ° Ñ‡ĞµÑ€ĞµĞ· Whisper (Ñ‡ĞµÑ€ĞµĞ· executor).
    """
    loop = asyncio.get_running_loop()

    try:
        result = await loop.run_in_executor(
            None,
            lambda: model.transcribe(file_path, language=language)
        )
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ñ‚Ñ€Ğ°Ğ½ÑĞºÑ€Ğ¸Ğ±Ğ°Ñ†Ğ¸Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ° {file_path}: {e}", exc_info=True)
        return ""
â”‚       â”œâ”€â”€ whisper_service.py
from pathlib import Path
import whisper
import torch
import asyncio
import logging

logger = logging.getLogger(__name__)

try:
    if torch.cuda.is_available():
        device = "cuda"
    elif torch.backends.mps.is_available():
        device = "mps"
    else:
        device = "cpu"
    logger.info(f"Whisper Ğ±ÑƒĞ´ĞµÑ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾: {device}")
    model = whisper.load_model("base", device=device)
except Exception as e:
    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Whisper: {e}", exc_info=True)
    model = whisper.load_model("base", device="cpu")

async def transcribe_voice(file_path: str, language: str = None) -> str:
    """
    ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞºÑ€Ğ¸Ğ±Ğ°Ñ†Ğ¸Ñ Ğ°ÑƒĞ´Ğ¸Ğ¾Ñ„Ğ°Ğ¹Ğ»Ğ° Ñ‡ĞµÑ€ĞµĞ· Whisper (Ñ‡ĞµÑ€ĞµĞ· executor).
    """
    loop = asyncio.get_running_loop()

    try:
        result = await loop.run_in_executor(
            None,
            lambda: model.transcribe(file_path, language=language)
        )
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ñ‚Ñ€Ğ°Ğ½ÑĞºÑ€Ğ¸Ğ±Ğ°Ñ†Ğ¸Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ° {file_path}: {e}", exc_info=True)
        return ""
â”‚       â””â”€â”€ yougile_service.py
import aiohttp
import logging
from apps.service.settings_service import get_default_yougile_data

logger = logging.getLogger(__name__)


async def create_task(title: str, description: str = "", priority: str = "task-green", deadline_ts: int = None) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]
    column_id = data["column_id"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    payload = {
        "title": title[:100],
        "description": description,
        "columnId": column_id,
        "archived": False,
        "completed": False,
        "color": priority
    }

    if deadline_ts:
        payload["deadline"] = {
            "deadline": deadline_ts,
            "startDate": deadline_ts,
            "withTime": False,
            "history": [],
            "blockedPoints": [],
            "links": []
        }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post("https://api.yougile.com/api-v2/tasks", json=payload, headers=headers) as response:
                response_json = await response.json()
                if response.status in (200, 201) and "id" in response_json:
                    logger.info(f"âœ… Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ² YouGile: {response_json['id']}")
                    return True
                else:
                    logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸: {response.status} {response_json}")
                    return False
    except Exception as e:
        logger.error(f"âŒ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸: {e}", exc_info=True)
        return False


async def get_tasks(limit: int = 10, offset: int = 0) -> list[dict]:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/task-list?limit={limit}&offset={offset}"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                response_json = await response.json()
                if response.status == 200 and isinstance(response_json, dict):
                    return response_json.get("content", [])
                else:
                    logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡: {response.status} â€” {response_json}")
                    return []
    except Exception as e:
        logger.error(f"âŒ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡: {e}", exc_info=True)
        return []


async def delete_task(task_id: str) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/tasks/{task_id}"
    payload = {
        "deleted": True
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers, json=payload) as response:
                if response.status in (200, 204):
                    logger.info(f"ğŸ—‘ Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° {task_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°.")
                    return True
                else:
                    text = await response.text()
                    logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ {task_id}: {response.status} â€” {text}")
                    return False
    except Exception as e:
        logger.error(f"âŒ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ {task_id}: {e}", exc_info=True)
        return False


async def update_task(task_id: str, title: str, description: str = "", priority: str = "task-green", deadline_ts: int = None) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]
    column_id = data["column_id"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    payload = {
        "title": title[:100],
        "description": description,
        "columnId": column_id,
        "archived": False,
        "completed": False,
        "color": priority
    }

    if deadline_ts:
        payload["deadline"] = {
            "deadline": deadline_ts,
            "startDate": deadline_ts,
            "withTime": False,
            "history": [],
            "blockedPoints": [],
            "links": []
        }

    url = f"https://api.yougile.com/api-v2/tasks/{task_id}"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(url, json=payload, headers=headers) as response:
                response_json = await response.json()
                if response.status in (200, 204):
                    logger.info(f"âœï¸ Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° {task_id} Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°.")
                    return True
                else:
                    logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ {task_id}: {response.status} â€” {response_json}")
                    return False
    except Exception as e:
        logger.error(f"âŒ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ {task_id}: {e}", exc_info=True)
        return False
â”œâ”€â”€ core
â”‚   â”œâ”€â”€ asgi.py
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ settings.py
â”‚   â”œâ”€â”€ urls.py
â”‚   â””â”€â”€ wsgi.py
â”œâ”€â”€ db.sqlite3
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ manage.py
â”œâ”€â”€ nginx
â”‚   â””â”€â”€ default.conf
â”œâ”€â”€ requirements.txt