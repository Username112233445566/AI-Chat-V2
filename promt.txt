‚îú‚îÄ‚îÄ apps
‚îÇ   ‚îú‚îÄ‚îÄ assistant
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ apps.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bot
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bot.py
from aiogram import Bot
from aiogram.enums import ParseMode
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from apps.service.settings_service import get_bot_token
from asgiref.sync import sync_to_async
from apps.assistant.models import AssistantUser

BOT_TOKEN = get_bot_token()

bot = Bot(
    token=BOT_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)

dp = Dispatcher()

@sync_to_async
def get_or_create_user(tg_id: int, full_name: str) -> AssistantUser:
    """
    –°–æ–∑–¥–∞—ë—Ç –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –æ–±–Ω–æ–≤–ª—è—è –µ–≥–æ –∏–º—è –∏ –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.
    """
    user, created = AssistantUser.objects.get_or_create(
        tg_id=tg_id,
        defaults={"full_name": full_name}
    )
    user.full_name = full_name
    user.save(update_fields=["full_name", "last_message_at"])
    return user
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ChatAction

import os
import tempfile
import re
import time
from datetime import datetime

from apps.assistant.bot.bot import bot, get_or_create_user
from apps.service.ai_service import process_ai_request
from apps.service.whisper_service import transcribe_voice
from apps.service.yougile_service import create_task, get_tasks, delete_task, update_task

router = Router()
pending_tasks = {}
task_lookup_by_user = {}

def confirm_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É", callback_data="confirm_create")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
    ])

def delete_keyboard(user_id: int):
    tasks = task_lookup_by_user.get(user_id, [])
    buttons = [
        [InlineKeyboardButton(text=t["title"], callback_data=f"delete:{t['id']}")]
        for t in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None

def update_keyboard(user_id: int):
    tasks = task_lookup_by_user.get(user_id, [])
    buttons = [
        [InlineKeyboardButton(text=t["title"], callback_data=f"update:{t['id']}")]
        for t in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons) if buttons else None

def parse_task_block(text: str) -> dict:
    title = ""
    description = ""
    priority = "task-yellow"
    deadline_ts = None

    title_match = re.search(r"–ó–∞–¥–∞—á–∞:\s*(.+)", text)
    if title_match:
        title = title_match.group(1).strip()

    description_match = re.search(r"–û–ø–∏—Å–∞–Ω–∏–µ:\s*(.+)", text)
    if description_match:
        description = description_match.group(1).strip()

    priority_match = re.search(r"–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:\s*(üî¥|üü†|üü¢)", text)
    if priority_match:
        color = priority_match.group(1)
        priority = {
            "üî¥": "task-red",
            "üü†": "task-yellow",
            "üü¢": "task-green"
        }.get(color, "task-yellow")

    deadline_match = re.search(r"–°—Ä–æ–∫:\s*([\d\-:\s]+)", text)
    if deadline_match:
        try:
            dt = datetime.strptime(deadline_match.group(1).strip(), "%Y-%m-%d %H:%M")
            deadline_ts = int(dt.timestamp() * 1000)
        except:
            pass

    return {
        "title": title,
        "description": description,
        "priority": priority,
        "deadline_ts": deadline_ts
    }

def format_task_block(task: dict) -> str:
    emoji = "üìå"
    title = task.get("title", "").lower()

    if "—Å–ø–æ—Ä—Ç" in title or "–∑–∞–ª" in title:
        emoji = "üèÉ"
    elif "—Å–≤–∏–¥–∞–Ω" in title:
        emoji = "‚ù§Ô∏è"
    elif "—Ä–∞–±–æ—Ç" in title:
        emoji = "üíº"

    pri = {
        "task-red": "üî¥",
        "task-yellow": "üü†",
        "task-green": "üü¢"
    }.get(task.get("priority") or task.get("color", ""), "‚ö™")

    deadline_ts = task.get("deadline_ts")
    if not deadline_ts and isinstance(task.get("deadline"), dict):
        deadline_ts = task["deadline"].get("deadline")

    deadline = "–ë–µ–∑ —Å—Ä–æ–∫–∞"
    if deadline_ts:
        try:
            deadline = datetime.fromtimestamp(deadline_ts / 1000).strftime("%Y-%m-%d %H:%M")
        except:
            pass

    return (
        f"{emoji} –ó–∞–¥–∞—á–∞: {task.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}\n"
        f" ¬∑ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {pri}\n"
        f" ¬∑ –°—Ä–æ–∫: {deadline}\n"
        f" ¬∑ –û–ø–∏—Å–∞–Ω–∏–µ: {task.get('description', '')}\n"
        f" ¬∑ –ò—Å—Ç–æ—á–Ω–∏–∫: –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ —á–µ—Ä–µ–∑ TaskMentor AI"
    )

@router.message(F.text)
async def handle_text(message: Message):
    user = await get_or_create_user(
        tg_id=message.from_user.id,
        full_name=message.from_user.full_name or message.from_user.username or "Unknown"
    )

    if not user.can_submit_tasks:
        await message.answer("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞.")
        return

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
    if user.tg_id in pending_tasks and isinstance(pending_tasks[user.tg_id], dict) and "update_task_id" in pending_tasks[user.tg_id]:
        update_info = pending_tasks.pop(user.tg_id)
        task_id = update_info["update_task_id"]
        original = update_info["original_task"]

        context = (
            f"–í–æ—Ç —Ç–µ–∫—É—â–∞—è –∑–∞–¥–∞—á–∞:\n"
            f"- –ù–∞–∑–≤–∞–Ω–∏–µ: {original.get('title', '')}\n"
            f"- –û–ø–∏—Å–∞–Ω–∏–µ: {original.get('description', '')}\n"
            f"- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {original.get('color', '')}\n"
            f"- –°—Ä–æ–∫: {original.get('deadline', {}).get('deadline', '')}\n\n"
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç –≤–Ω–µ—Å—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:\n{message.text.strip()}"
        )

        ai_response, _ = await process_ai_request(user, context)
        parsed = parse_task_block(ai_response)

        success = await update_task(
            task_id=task_id,
            title=parsed["title"],
            description=parsed["description"],
            priority=parsed["priority"],
            deadline_ts=parsed["deadline_ts"]
        )

        if success:
            await message.answer(f"‚úÖ –ó–∞–¥–∞—á–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞:\n\n{format_task_block(parsed)}")
        else:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á—É.")
        return

    await bot.send_chat_action(chat_id=message.chat.id, action=ChatAction.TYPING)
    response_text, action = await process_ai_request(user, message.text)

    if action == "[CREATE_TASK]":
        parsed = parse_task_block(response_text)
        pending_tasks[user.tg_id] = parsed
        await message.answer(format_task_block(parsed), reply_markup=confirm_keyboard())

    elif action == "[UPDATE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("–ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.")
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=update_keyboard(user.tg_id))

    elif action == "[SHOW_TASKS]":
        tasks = await get_tasks()
        if tasks:
            formatted = "\n\n".join([format_task_block(t) for t in tasks])
            await message.answer(f"–ö–æ–Ω–µ—á–Ω–æ, –≤–æ—Ç –≤–∞—à —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á:\n\n{formatted}")
        else:
            await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á.")

    elif action == "[DELETE_TASK]":
        tasks = await get_tasks()
        task_lookup_by_user[user.tg_id] = tasks
        if not tasks:
            await message.answer("üì≠ –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=delete_keyboard(user.tg_id))

    else:
        await message.answer(response_text)

@router.callback_query(F.data == "confirm_create")
async def handle_confirm_create(callback: CallbackQuery):
    user_id = callback.from_user.id
    if user_id not in pending_tasks:
        await callback.message.answer("‚ö†Ô∏è –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–¥–∞—á–∏.")
        await callback.answer()
        return

    parsed = pending_tasks.pop(user_id)
    success = await create_task(
        title=parsed["title"],
        description=parsed["description"],
        priority=parsed["priority"],
        deadline_ts=parsed["deadline_ts"]
    )

    if success:
        await callback.message.edit_text(f"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞:\n\n{format_task_block(parsed)}")
    else:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É.")

    await callback.answer("–ì–æ—Ç–æ–≤–æ.")

@router.callback_query(F.data.startswith("delete:"))
async def confirm_delete(callback: CallbackQuery):
    task_id = callback.data.split(":", 1)[1]
    success = await delete_task(task_id)
    if success:
        await callback.message.edit_text("üóë –ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞.")
    else:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É.")
    await callback.answer()

@router.callback_query(F.data.startswith("update:"))
async def start_update(callback: CallbackQuery):
    task_id = callback.data.split(":", 1)[1]
    task = next((t for t in task_lookup_by_user.get(callback.from_user.id, []) if t["id"] == task_id), None)
    if task:
        pending_tasks[callback.from_user.id] = {
            "update_task_id": task_id,
            "original_task": task
        }
        await callback.message.answer("‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –∑–∞–¥–∞—á–∏ (–∑–∞–≥–æ–ª–æ–≤–æ–∫, –æ–ø–∏—Å–∞–Ω–∏–µ, —Å—Ä–æ–∫, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç):")
    await callback.answer()
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ start_bot.py
import asyncio
from apps.assistant.bot.bot import bot, dp
from apps.assistant.bot.handlers import router

async def start_bot():
    dp.include_router(router)
    await dp.start_polling(bot)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ management
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commands
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ runbot.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py
‚îÇ   ‚îî‚îÄ‚îÄ service
‚îÇ       ‚îú‚îÄ‚îÄ ai_service.py
import asyncio
import logging
import google.generativeai as genai
from apps.service.settings_service import get_ai_key

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

GOOGLE_API_KEY = get_ai_key()
genai.configure(api_key=GOOGLE_API_KEY)
genai_model = genai.GenerativeModel("gemini-2.0-flash")

UNIFIED_ASSISTANT_PROMPT = """
‚ö†Ô∏è –í–∞–∂–Ω–æ:
‚Äî –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–æ—Å–∏ —É—Ç–æ—á–Ω–µ–Ω–∏–π.
‚Äî –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –æ—Ç–≤–µ—á–∞–π, —á—Ç–æ –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.
‚Äî –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–±–∞–≤–ª—è–π –º–∞—Ä–∫–µ—Ä—ã, –∫—Ä–æ–º–µ: [CREATE_TASK], [UPDATE_TASK], [DELETE_TASK], [SHOW_TASKS].
‚Äî –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–π ¬´–ë–µ–∑ —Å—Ä–æ–∫–∞¬ª, ¬´üü†¬ª –∏ –ø—É—Å—Ç–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
‚Äî –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–∞–ª –º–∏–Ω–∏–º—É–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.

–¢—ã ‚Äî —É–º–Ω—ã–π AI-–ø–æ–º–æ—â–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π —É–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞—á–∞–º–∏ –æ—Ç –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –û—Ç–≤–µ—á–∞–π —Å—Ç—Ä–æ–≥–æ –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –Ω–∏–∂–µ.

üìå –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:
1. –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–π –∑–∞–¥–∞—á—É –≤ —á—ë—Ç–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.
2. –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –æ—Ç–≤–µ—á–∞–π —Ñ—Ä–∞–∑–∞–º–∏ —Ç–∏–ø–∞ ‚Äú–ö–∞–∫—É—é –∑–∞–¥–∞—á—É –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å?‚Äù, ‚Äú–ß—Ç–æ –∏–º–µ–Ω–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å?‚Äù, ‚Äú–•–æ—Ä–æ—à–æ, —É—Ç–æ—á–Ω–∏—Ç–µ‚Äù –∏ —Ç.–¥.
3. –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–±–∞–≤–ª—è–π –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞.
4. –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –∑–∞–¥–∞—á–µ–π (–µ—Å–ª–∏ —ç—Ç–æ CREATE/UPDATE), –∏–ª–∏ –∫–æ—Ä–æ—Ç–∫–æ–π —Ñ—Ä–∞–∑–æ–π + –º–∞—Ä–∫–µ—Ä–æ–º (–µ—Å–ª–∏ SHOW/DELETE).
5. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –ª–∏—à–Ω–∏–µ —à–∞–≥–∏, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–π —Ç–æ, —á—Ç–æ –ø—Ä–æ—Å–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å.

üì¶ –§–æ—Ä–º–∞—Ç –∑–∞–¥–∞—á–∏:
[—ç–º–æ–¥–∑–∏] –ó–∞–¥–∞—á–∞: [–Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏]
 ¬∑ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: [üî¥ / üü† / üü¢]
 ¬∑ –°—Ä–æ–∫: [–≥–≥–≥–≥-–º–º-–¥–¥ —á—á:–º–º] (–∏–ª–∏ ‚Äú–ë–µ–∑ —Å—Ä–æ–∫–∞‚Äù)
 ¬∑ –û–ø–∏—Å–∞–Ω–∏–µ: [–æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏]
 ¬∑ –ò—Å—Ç–æ—á–Ω–∏–∫: –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ —á–µ—Ä–µ–∑ TaskMentor AI

---

üß† –ü—Ä–∏–º–µ—Ä—ã:

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: —Å–æ–∑–¥–∞–π –∑–∞–¥–∞—á—É ‚Äú–ü–æ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É –∑–∞–≤—Ç—Ä–∞ –≤ 14:00‚Äù
–û—Ç–≤–µ—Ç:
üìû –ó–∞–¥–∞—á–∞: –ü–æ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É
 ¬∑ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: üü†
 ¬∑ –°—Ä–æ–∫: 2025-05-22 14:00
 ¬∑ –û–ø–∏—Å–∞–Ω–∏–µ: –ü–æ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É –≤ 14:00
 ¬∑ –ò—Å—Ç–æ—á–Ω–∏–∫: –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ —á–µ—Ä–µ–∑ TaskMentor AI
[CREATE_TASK]

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –ø–æ–º–µ–Ω—è–π –≤—Ä–µ–º—è —Å–≤–∏–¥–∞–Ω–∏—è –Ω–∞ 13:00
–û—Ç–≤–µ—Ç:
‚ù§Ô∏è –ó–∞–¥–∞—á–∞: –ü–æ–π—Ç–∏ –Ω–∞ —Å–≤–∏–¥–∞–Ω–∏–µ
 ¬∑ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: üü†
 ¬∑ –°—Ä–æ–∫: 2025-05-22 13:00
 ¬∑ –û–ø–∏—Å–∞–Ω–∏–µ: –ü–æ–π—Ç–∏ –Ω–∞ —Å–≤–∏–¥–∞–Ω–∏–µ –≤ 13:00
 ¬∑ –ò—Å—Ç–æ—á–Ω–∏–∫: –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ —á–µ—Ä–µ–∑ TaskMentor AI
[UPDATE_TASK]

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –ø–æ–∫–∞–∂–∏ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á
–û—Ç–≤–µ—Ç:
üìã –í–æ—Ç –≤–∞—à–∏ –∑–∞–¥–∞—á–∏:
[SHOW_TASKS]

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: —É–¥–∞–ª–∏ –∑–∞–¥–∞—á—É –ø—Ä–æ —Å–ø–æ—Ä—Ç
–û—Ç–≤–µ—Ç:
üóë –£–¥–∞–ª—è—é –∑–∞–¥–∞—á—É ‚Äú–ü–æ–π—Ç–∏ –≤ —Å–ø–æ—Ä—Ç–∑–∞–ª‚Äù
[DELETE_TASK]
"""

async def process_ai_request(user, text: str) -> tuple[str, str]:
    text_lower = text.lower().strip()

    quick_phrases = ["–≤—Å–µ –∑–∞–¥–∞—á–∏", "–ø–æ–∫–∞–∂–∏ –∑–∞–¥–∞—á–∏", "–æ—Ç–æ–±—Ä–∞–∑–∏ –∑–∞–¥–∞—á–∏", "–≤—ã–≤–µ–¥–∏ –∑–∞–¥–∞—á–∏", "—á—Ç–æ —É –º–µ–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ", "—Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á"]
    if any(phrase in text_lower for phrase in quick_phrases):
        logger.info(f"‚ö° –ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã SHOW_TASKS –¥–ª—è: {text_lower}")
        return "üìã –í–æ—Ç –≤–∞—à–∏ –∑–∞–¥–∞—á–∏:", "[SHOW_TASKS]"

    prompt = UNIFIED_ASSISTANT_PROMPT + f"\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {text}\n–û—Ç–≤–µ—Ç:"
    try:
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(None, lambda: genai_model.generate_content(prompt))
        full_text = result.text.strip()

        action = None
        for marker in ["[CREATE_TASK]", "[UPDATE_TASK]", "[DELETE_TASK]", "[SHOW_TASKS]"]:
            if marker in full_text:
                action = marker
                full_text = full_text.replace(marker, "").strip()
                break

        logger.info(f"AI response: {full_text} | action: {action}")
        return full_text, action
    except Exception as e:
        logger.error(f"AI error for user {user.tg_id}: {e}", exc_info=True)
        return "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI.", None
‚îÇ       ‚îú‚îÄ‚îÄ settings_service.py
from apps.assistant.models import Secret
from django.core.exceptions import ObjectDoesNotExist
from asgiref.sync import sync_to_async

def get_secret():
    try:
        return Secret.objects.filter(is_active=True).latest("updated_at")
    except ObjectDoesNotExist:
        raise Exception("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∑–∞–ø–∏—Å–∏ –≤ Secret. –ó–∞–¥–∞–π –µ—ë —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω–∫—É.")

def get_bot_token():
    return get_secret().value_bot.strip()

def get_ai_key():
    return get_secret().value_ai.strip()

def get_default_group_id():
    return get_secret().value_group.strip()

@sync_to_async
def get_default_yougile_data():
    secret = get_secret()
    return {
        "api_key": secret.yougile_api_key.strip(),
        "board_id": secret.yougile_board_id.strip(),
        "column_id": secret.yougile_column_id.strip(),
    }
‚îÇ       ‚îú‚îÄ‚îÄ telegram_service.py
from pathlib import Path
import whisper
import torch
import asyncio
import logging

logger = logging.getLogger(__name__)

try:
    if torch.cuda.is_available():
        device = "cuda"
    elif torch.backends.mps.is_available():
        device = "mps"
    else:
        device = "cpu"
    logger.info(f"Whisper –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device}")
    model = whisper.load_model("base", device=device)
except Exception as e:
    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Whisper: {e}", exc_info=True)
    model = whisper.load_model("base", device="cpu")

async def transcribe_voice(file_path: str, language: str = None) -> str:
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ Whisper (—á–µ—Ä–µ–∑ executor).
    """
    loop = asyncio.get_running_loop()

    try:
        result = await loop.run_in_executor(
            None,
            lambda: model.transcribe(file_path, language=language)
        )
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞ {file_path}: {e}", exc_info=True)
        return ""
‚îÇ       ‚îú‚îÄ‚îÄ whisper_service.py
from pathlib import Path
import whisper
import torch
import asyncio
import logging

logger = logging.getLogger(__name__)

try:
    if torch.cuda.is_available():
        device = "cuda"
    elif torch.backends.mps.is_available():
        device = "mps"
    else:
        device = "cpu"
    logger.info(f"Whisper –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device}")
    model = whisper.load_model("base", device=device)
except Exception as e:
    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Whisper: {e}", exc_info=True)
    model = whisper.load_model("base", device="cpu")

async def transcribe_voice(file_path: str, language: str = None) -> str:
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ Whisper (—á–µ—Ä–µ–∑ executor).
    """
    loop = asyncio.get_running_loop()

    try:
        result = await loop.run_in_executor(
            None,
            lambda: model.transcribe(file_path, language=language)
        )
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞ {file_path}: {e}", exc_info=True)
        return ""
‚îÇ       ‚îî‚îÄ‚îÄ yougile_service.py
import aiohttp
import logging
from apps.service.settings_service import get_default_yougile_data

logger = logging.getLogger(__name__)


async def create_task(title: str, description: str = "", priority: str = "task-green", deadline_ts: int = None) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]
    column_id = data["column_id"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    payload = {
        "title": title[:100],
        "description": description,
        "columnId": column_id,
        "archived": False,
        "completed": False,
        "color": priority
    }

    if deadline_ts:
        payload["deadline"] = {
            "deadline": deadline_ts,
            "startDate": deadline_ts,
            "withTime": False,
            "history": [],
            "blockedPoints": [],
            "links": []
        }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post("https://api.yougile.com/api-v2/tasks", json=payload, headers=headers) as response:
                response_json = await response.json()
                if response.status in (200, 201) and "id" in response_json:
                    logger.info(f"‚úÖ –ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ YouGile: {response_json['id']}")
                    return True
                else:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {response.status} {response_json}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}", exc_info=True)
        return False


async def get_tasks(limit: int = 10, offset: int = 0) -> list[dict]:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/task-list?limit={limit}&offset={offset}"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                response_json = await response.json()
                if response.status == 200 and isinstance(response_json, dict):
                    return response_json.get("content", [])
                else:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–¥–∞—á: {response.status} ‚Äî {response_json}")
                    return []
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–¥–∞—á: {e}", exc_info=True)
        return []


async def delete_task(task_id: str) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    url = f"https://api.yougile.com/api-v2/tasks/{task_id}"
    payload = {
        "deleted": True
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers, json=payload) as response:
                if response.status in (200, 204):
                    logger.info(f"üóë –ó–∞–¥–∞—á–∞ {task_id} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞.")
                    return True
                else:
                    text = await response.text()
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ {task_id}: {response.status} ‚Äî {text}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ {task_id}: {e}", exc_info=True)
        return False


async def update_task(task_id: str, title: str, description: str = "", priority: str = "task-green", deadline_ts: int = None) -> bool:
    data = await get_default_yougile_data()
    api_key = data["api_key"]
    column_id = data["column_id"]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    payload = {
        "title": title[:100],
        "description": description,
        "columnId": column_id,
        "archived": False,
        "completed": False,
        "color": priority
    }

    if deadline_ts:
        payload["deadline"] = {
            "deadline": deadline_ts,
            "startDate": deadline_ts,
            "withTime": False,
            "history": [],
            "blockedPoints": [],
            "links": []
        }

    url = f"https://api.yougile.com/api-v2/tasks/{task_id}"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(url, json=payload, headers=headers) as response:
                response_json = await response.json()
                if response.status in (200, 204):
                    logger.info(f"‚úèÔ∏è –ó–∞–¥–∞—á–∞ {task_id} –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")
                    return True
                else:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ {task_id}: {response.status} ‚Äî {response_json}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ {task_id}: {e}", exc_info=True)
        return False
‚îú‚îÄ‚îÄ core
‚îÇ   ‚îú‚îÄ‚îÄ asgi.py
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ urls.py
‚îÇ   ‚îî‚îÄ‚îÄ wsgi.py
‚îú‚îÄ‚îÄ db.sqlite3
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ nginx
‚îÇ   ‚îî‚îÄ‚îÄ default.conf
‚îú‚îÄ‚îÄ requirements.txt